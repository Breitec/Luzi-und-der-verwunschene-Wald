<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Luzi und der verwunschene Wald ğŸŒ¸</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #1a0a2e;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    font-family: 'Georgia', serif;
    overflow: hidden;
  }
  #game-container {
    position: relative;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 0 60px rgba(255,150,255,0.4), 0 0 120px rgba(100,50,200,0.3);
  }
  canvas { display: block; }
</style>
</head>
<body>
<div id="game-container">
  <canvas id="gameCanvas"></canvas>
</div>

<script>
'use strict';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš™ï¸  KONSTANTEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const STATE = {
  MENU:           'menu',
  PLAYING:        'playing',
  LEVEL_COMPLETE: 'level_complete',
  GAME_OVER:      'game_over',
  WIN:            'win',
};

const CONFIG = {
  CANVAS:  { W: 800, H: 450 },
  PHYSICS: { GRAVITY: 0.55, JUMP: -13, SPEED: 3.5 },
  PLAYER:  { INVINCIBLE_FRAMES: 120, KNOCKOUT_FRAMES: 80, SHOOT_COOLDOWN: 22, KNOCKBACK_VY: -9 },
  AUDIO:   { MASTER_VOL: 0.45, NOTE: 0.16 },
  PARTICLE:{ DECAY: 0.025 },
};

// â”€â”€â”€ LEVEL-DATEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const LEVEL_DATA = [
  {
    name: "Der Graue Hain",
    bgColor: ['#2d1b4e', '#1a2a1a'],
    treesGray: true,
    platforms: [
      {x:0,   y:400, w:800, h:50},
      {x:150, y:320, w:100, h:16},
      {x:350, y:270, w:120, h:16},
      {x:550, y:310, w:100, h:16},
      {x:680, y:230, w:110, h:16},
    ],
    enemies: [
      {x:300, y:364, type:'mushroom', dir:1,  speed:1.2},
      {x:500, y:364, type:'mushroom', dir:-1, speed:1.4},
      {x:690, y:194, type:'mushroom', dir:1,  speed:1.0},
    ],
  },
  {
    name: "Der Schlafende Fluss",
    bgColor: ['#1a1a3e', '#0d2233'],
    iceEffect: true,
    platforms: [
      {x:0,   y:400, w:800, h:50},
      {x:240, y:355, w:90,  h:16},
      {x:390, y:310, w:90,  h:16},
      {x:540, y:270, w:90,  h:16},
      {x:670, y:330, w:120, h:16},
    ],
    enemies: [
      {x:250, y:322, type:'crow', dir:1,  speed:2.0, floatY:322, floatRange:22},
      {x:545, y:238, type:'crow', dir:-1, speed:2.2, floatY:238, floatRange:28},
      {x:395, y:278, type:'crow', dir:1,  speed:1.8, floatY:278, floatRange:18},
    ],
  },
  {
    name: "Das Herz des Waldes",
    bgColor: ['#0d0d1a', '#1a0d2e'],
    darkEffect: true,
    platforms: [
      {x:0,   y:400, w:800, h:50},
      {x:100, y:310, w:120, h:16},
      {x:300, y:260, w:100, h:16},
      {x:480, y:310, w:100, h:16},
      {x:620, y:240, w:130, h:16},
    ],
    enemies: [
      {x:200, y:364, type:'shadow', dir:1,  speed:1.5},
      {x:500, y:364, type:'shadow', dir:-1, speed:1.7},
      {x:650, y:204, type:'boss',   dir:1,  speed:2.2, hp:3},
    ],
  },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§  PHYSIK-HILFSFUNKTIONEN  (rein, kein globaler Zustand)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function overlap(a, b) {
  return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y;
}

function resolveGround(obj, platforms) {
  obj.onGround = false;
  platforms.forEach(p => {
    if (!p.invisible &&
        obj.x+obj.w > p.x && obj.x < p.x+p.w &&
        obj.vy >= 0 &&
        obj.y+obj.h >= p.y && obj.y+obj.h <= p.y+24) {
      obj.y  = p.y - obj.h;
      obj.vy = 0;
      obj.onGround = true;
    }
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”Š  AUDIO ENGINE  (Web Audio API â€“ kein Download!)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class AudioEngine {
  constructor() {
    this._ctx          = null;
    this._master       = null;
    this._musicRunning = false;
  }

  _getContext() {
    if (!this._ctx) this._ctx = new (window.AudioContext || window.webkitAudioContext)();
    return this._ctx;
  }

  _getMaster() {
    const ac = this._getContext();
    if (!this._master) {
      this._master = ac.createGain();
      this._master.gain.value = CONFIG.AUDIO.MASTER_VOL;
      this._master.connect(ac.destination);
    }
    return this._master;
  }

  // â”€â”€ ğŸº  TÃ¶rÃ¶Ã¶Ã¶!  Elefantentrompete â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  playTrompete() {
    const ac = this._getContext();
    const g = ac.createGain();
    g.connect(this._getMaster());

    // Kurze Auftakt-Pffffts
    [[300,0],[420,0.07],[550,0.14],[380,0.22]].forEach(([f,t]) => {
      const o = ac.createOscillator(), og = ac.createGain();
      o.type = 'sawtooth'; o.frequency.value = f;
      og.gain.setValueAtTime(0, ac.currentTime+t);
      og.gain.linearRampToValueAtTime(0.15, ac.currentTime+t+0.025);
      og.gain.exponentialRampToValueAtTime(0.001, ac.currentTime+t+0.09);
      o.connect(og); og.connect(g);
      o.start(ac.currentTime+t); o.stop(ac.currentTime+t+0.12);
    });

    // Das lange TÃ¶rÃ¶Ã¶Ã¶
    const o2 = ac.createOscillator(), og2 = ac.createGain();
    o2.type = 'sawtooth';
    o2.frequency.setValueAtTime(300, ac.currentTime+0.28);
    o2.frequency.exponentialRampToValueAtTime(560, ac.currentTime+0.55);
    o2.frequency.exponentialRampToValueAtTime(180, ac.currentTime+1.0);
    og2.gain.setValueAtTime(0, ac.currentTime+0.28);
    og2.gain.linearRampToValueAtTime(0.24, ac.currentTime+0.34);
    og2.gain.setValueAtTime(0.24, ac.currentTime+0.55);
    og2.gain.exponentialRampToValueAtTime(0.001, ac.currentTime+1.05);
    o2.connect(og2); og2.connect(g);
    o2.start(ac.currentTime+0.28); o2.stop(ac.currentTime+1.1);

    // Oberton fÃ¼r WÃ¤rme
    const o3 = ac.createOscillator(), og3 = ac.createGain();
    o3.type = 'square';
    o3.frequency.setValueAtTime(600, ac.currentTime+0.28);
    o3.frequency.exponentialRampToValueAtTime(1120, ac.currentTime+0.55);
    o3.frequency.exponentialRampToValueAtTime(360, ac.currentTime+1.0);
    og3.gain.setValueAtTime(0, ac.currentTime+0.28);
    og3.gain.linearRampToValueAtTime(0.06, ac.currentTime+0.34);
    og3.gain.exponentialRampToValueAtTime(0.001, ac.currentTime+1.05);
    o3.connect(og3); og3.connect(g);
    o3.start(ac.currentTime+0.28); o3.stop(ac.currentTime+1.1);
  }

  // â”€â”€ ğŸ’¨  Blumen-Abschuss Whoosh â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  playWhoosh() {
    const ac = this._getContext();
    const len = Math.floor(ac.sampleRate * 0.12);
    const buf = ac.createBuffer(1, len, ac.sampleRate);
    const d   = buf.getChannelData(0);
    for (let i = 0; i < len; i++) d[i] = (Math.random()*2-1)*(1-i/len);
    const src = ac.createBufferSource(); src.buffer = buf;
    const bpf = ac.createBiquadFilter();
    bpf.type = 'bandpass'; bpf.frequency.value = 1200; bpf.Q.value = 1.2;
    const g = ac.createGain();
    g.gain.setValueAtTime(0.2, ac.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, ac.currentTime+0.14);
    src.connect(bpf); bpf.connect(g); g.connect(this._getMaster()); src.start();

    // Magisches Pling dazu
    const o = ac.createOscillator(), og = ac.createGain();
    o.type = 'sine';
    o.frequency.setValueAtTime(1046, ac.currentTime);
    o.frequency.exponentialRampToValueAtTime(1760, ac.currentTime+0.1);
    og.gain.setValueAtTime(0.09, ac.currentTime);
    og.gain.exponentialRampToValueAtTime(0.001, ac.currentTime+0.14);
    o.connect(og); og.connect(this._getMaster());
    o.start(); o.stop(ac.currentTime+0.15);
  }

  // â”€â”€ ğŸ’¥  Blume trifft Gegner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  playHit() {
    const ac = this._getContext();
    // FrÃ¶hliche Dur-Arpeggio
    [523,659,784,1047].forEach((freq, i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.type = 'sine'; o.frequency.value = freq;
      const t = ac.currentTime + i*0.055;
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.14, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.001, t+0.18);
      o.connect(g); g.connect(this._getMaster());
      o.start(t); o.stop(t+0.2);
    });
    // Knall
    const len = Math.floor(ac.sampleRate*0.07);
    const buf = ac.createBuffer(1, len, ac.sampleRate);
    const d   = buf.getChannelData(0);
    for (let i = 0; i < len; i++) d[i] = (Math.random()*2-1)*(1-i/len)*0.6;
    const src = ac.createBufferSource(); src.buffer = buf;
    const g2 = ac.createGain(); g2.gain.value = 0.18;
    src.connect(g2); g2.connect(this._getMaster()); src.start();
  }

  // â”€â”€ ğŸ˜µ  Luzi Ohnmacht â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  playOuch() {
    const ac = this._getContext();
    const o = ac.createOscillator(), g = ac.createGain();
    o.type = 'sine';
    o.frequency.setValueAtTime(440, ac.currentTime);
    o.frequency.exponentialRampToValueAtTime(160, ac.currentTime+0.5);
    g.gain.setValueAtTime(0.22, ac.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, ac.currentTime+0.55);
    o.connect(g); g.connect(this._getMaster());
    o.start(); o.stop(ac.currentTime+0.6);
  }

  // â”€â”€ ğŸ‰  Level Complete â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  playLevelComplete() {
    const ac = this._getContext();
    const mel = [523,659,784,1047,784,1047,1319];
    const dur = [0.12,0.12,0.12,0.2,0.1,0.1,0.5];
    let t = ac.currentTime;
    mel.forEach((f, i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.type = 'triangle'; o.frequency.value = f;
      g.gain.setValueAtTime(0.18, t); g.gain.exponentialRampToValueAtTime(0.001, t+dur[i]);
      o.connect(g); g.connect(this._getMaster());
      o.start(t); o.stop(t+dur[i]+0.05);
      t += dur[i];
    });
  }

  // â”€â”€ ğŸµ  Hintergrundmusik â€“ Glockenspiel-Walzer in C-Dur â”€â”€
  startMusic() {
    if (this._musicRunning) return;
    this._musicRunning = true;
    const NOTE = CONFIG.AUDIO.NOTE;

    // Melodie: frÃ¶hliche C-Dur Phrasen
    const MEL = [
      523,659,784,659, 523,659,523,392,
      440,523,659,523, 440,523,440,349,
      392,523,659,784, 880,784,659,523,
      659,784,880,784, 659,523,392,523,
      523,659,784,880, 1047,880,784,659,
      784,659,523,440, 523,440,392,349,
      392,523,659,523, 392,349,330,294,
      330,392,523,659, 784,659,523,392,
    ];
    let idx = 0;
    const tick = () => {
      if (!this._musicRunning) return;
      const ac  = this._getContext();
      const freq = MEL[idx % MEL.length];
      const now  = ac.currentTime;

      // Glocken-Ton (Hauptmelodie)
      const o = ac.createOscillator(), g = ac.createGain();
      o.type = 'sine'; o.frequency.value = freq;
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.055, now+0.01);
      g.gain.exponentialRampToValueAtTime(0.001, now+NOTE*1.6);
      o.connect(g); g.connect(this._getMaster());
      o.start(now); o.stop(now+NOTE*1.8);

      // Shimmer-Oberton
      const o2 = ac.createOscillator(), g2 = ac.createGain();
      o2.type = 'triangle'; o2.frequency.value = freq*2;
      g2.gain.setValueAtTime(0, now);
      g2.gain.linearRampToValueAtTime(0.018, now+0.01);
      g2.gain.exponentialRampToValueAtTime(0.001, now+NOTE);
      o2.connect(g2); g2.connect(this._getMaster());
      o2.start(now); o2.stop(now+NOTE+0.05);

      idx++;
      setTimeout(tick, NOTE*1000);
    };

    // Bass â€“ alle 4 Noten
    const BASS = [130,130,146,164,130,130,146,164,110,130,146,164,130,146,164,130];
    let bi = 0;
    const bassT = () => {
      if (!this._musicRunning) return;
      const ac  = this._getContext();
      const now = ac.currentTime;
      const f   = BASS[bi % BASS.length];
      const o = ac.createOscillator(), g = ac.createGain();
      o.type = 'sine'; o.frequency.value = f;
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.065, now+0.02);
      g.gain.exponentialRampToValueAtTime(0.001, now+NOTE*4);
      o.connect(g); g.connect(this._getMaster());
      o.start(now); o.stop(now+NOTE*4+0.05);
      bi++;
      setTimeout(bassT, NOTE*4*1000);
    };

    // Walzer-Hintergrundakkorde
    const CHORDS = [[523,659,784],[440,554,659],[349,440,523],[392,494,587]];
    let ci = 0;
    const chordT = () => {
      if (!this._musicRunning) return;
      const ac  = this._getContext();
      const now = ac.currentTime;
      const ch  = CHORDS[ci % CHORDS.length];
      ch.forEach(f => {
        const o = ac.createOscillator(), g = ac.createGain();
        o.type = 'sine'; o.frequency.value = f;
        g.gain.setValueAtTime(0, now);
        g.gain.linearRampToValueAtTime(0.018, now+0.02);
        g.gain.exponentialRampToValueAtTime(0.001, now+NOTE*8);
        o.connect(g); g.connect(this._getMaster());
        o.start(now); o.stop(now+NOTE*8+0.05);
      });
      ci++;
      setTimeout(chordT, NOTE*8*1000);
    };

    tick();
    bassT();
    chordT();
  }

  stopMusic() { this._musicRunning = false; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âŒ¨ï¸  INPUT MANAGER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class InputManager {
  constructor() {
    this.keys     = {};
    this._handlers = [];
    window.addEventListener('keydown', e => {
      this.keys[e.key] = true;
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
      this._handlers.forEach(fn => fn(e));
    });
    window.addEventListener('keyup', e => { this.keys[e.key] = false; });
  }

  isDown(key)    { return !!this.keys[key]; }
  onKeyDown(fn)  { this._handlers.push(fn); }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âœ¨  PARTIKELSYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ParticleSystem {
  constructor() { this.particles = []; }

  spawn(x, y, n, color, spd) {
    for (let i = 0; i < n; i++) {
      const a = Math.random() * Math.PI * 2;
      const s = spd * (0.5 + Math.random());
      this.particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s-2, life: 1, color, size: 3+Math.random()*4 });
    }
  }

  update() {
    this.particles.forEach(p => { p.x+=p.vx; p.y+=p.vy; p.vy+=0.1; p.life-=CONFIG.PARTICLE.DECAY; });
    this.particles = this.particles.filter(p => p.life > 0);
  }

  draw(ctx) {
    this.particles.forEach(p => {
      ctx.globalAlpha = p.life;
      ctx.fillStyle   = p.color;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.size*p.life, 0, Math.PI*2); ctx.fill();
    });
    ctx.globalAlpha = 1;
  }

  clear() { this.particles = []; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨  RENDERER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Renderer {
  constructor(canvas) {
    this.ctx = canvas.getContext('2d');
    this.W   = CONFIG.CANVAS.W;
    this.H   = CONFIG.CANVAS.H;
  }

  clear() { this.ctx.clearRect(0, 0, this.W, this.H); }

  // â”€â”€ Hintergrund â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  drawBackground(level, bloomProgress) {
    const ctx = this.ctx;
    const [c1, c2] = level.bgColor;
    const gr = ctx.createLinearGradient(0, 0, 0, this.H);
    gr.addColorStop(0, c1); gr.addColorStop(1, c2);
    ctx.fillStyle = gr; ctx.fillRect(0, 0, this.W, this.H);

    // Sterne (deterministisch aus Level-Index)
    const seed = LEVEL_DATA.indexOf(level) * 13;
    ctx.fillStyle = 'rgba(255,255,255,0.45)';
    for (let i = 0; i < 40; i++) {
      ctx.beginPath();
      ctx.arc((seed+i*137)%this.W, (seed+i*97)%300, 0.5+(i%3)*0.5, 0, Math.PI*2);
      ctx.fill();
    }

    this._drawTrees(level, bloomProgress);

    if (level.darkEffect) {
      const vig = ctx.createRadialGradient(this.W/2, this.H/2, 80, this.W/2, this.H/2, this.W*0.75);
      vig.addColorStop(0, 'rgba(0,0,0,0)'); vig.addColorStop(1, 'rgba(0,0,0,0.72)');
      ctx.fillStyle = vig; ctx.fillRect(0, 0, this.W, this.H);
    }
  }

  _drawTrees(level, bloomProgress) {
    const ctx = this.ctx;
    [50,170,400,600,720].forEach(tx => {
      const bl = bloomProgress/100, gray = level.treesGray;
      ctx.fillStyle = gray&&bl<0.5 ? '#555' : '#5c3d1e';
      ctx.fillRect(tx+10, 310, 12, 90);
      [['#2d6a2d','#ff88cc'],['#3a8a3a','#ff66aa'],['#4aaa4a','#ffaadd']].forEach(([base,bloom], l) => {
        ctx.fillStyle   = bl>l*0.33 ? bloom : (gray?'#777':base);
        ctx.globalAlpha = 0.88;
        ctx.beginPath(); ctx.arc(tx+16, 318-l*22, 20-l*2, 0, Math.PI*2); ctx.fill();
      });
      ctx.globalAlpha = 1;
      if (level.darkEffect) {
        ctx.fillStyle = '#aa44ff'; ctx.globalAlpha = 0.6;
        ctx.beginPath(); ctx.arc(tx+16, 305, 5, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
      }
    });
  }

  // â”€â”€ Plattformen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  drawPlatforms(platforms, level, bloomProgress) {
    const ctx = this.ctx;
    platforms.forEach(p => {
      if (p.invisible) return;
      let t, b;
      if (level.iceEffect)        { t='#aaddff'; b='#6699bb'; }
      else if (level.darkEffect)  { t='#4a2a6a'; b='#2a1a3a'; }
      else                        { t='#5a8a3a'; b='#3a5a2a'; }
      const g = ctx.createLinearGradient(p.x, p.y, p.x, p.y+p.h);
      g.addColorStop(0, t); g.addColorStop(1, b);
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.roundRect(p.x, p.y, p.w, p.h, p.h>30?0:8); ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.15)'; ctx.fillRect(p.x+2, p.y, p.w-4, 4);

      if (!level.iceEffect && !level.darkEffect && bloomProgress>25) {
        ctx.fillStyle = '#ff88cc';
        for (let gx = p.x+10; gx < p.x+p.w-10; gx += 18) {
          ctx.beginPath(); ctx.arc(gx, p.y-3, 3*(bloomProgress/100), 0, Math.PI*2); ctx.fill();
        }
      }
      if (level.darkEffect) {
        ctx.fillStyle = '#aa44ff'; ctx.globalAlpha = 0.65;
        for (let gx = p.x+14; gx < p.x+p.w-14; gx += 24) {
          ctx.beginPath(); ctx.arc(gx, p.y-5, 4, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha = 1;
      }
    });
  }

  // â”€â”€ BlÃ¼mchen-Sprite â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _tinyFlower(x, y, color, sz) {
    const ctx = this.ctx;
    ctx.save(); ctx.translate(x, y);
    ctx.fillStyle = color;
    for (let i = 0; i < 5; i++) {
      ctx.save(); ctx.rotate(i*Math.PI*2/5);
      ctx.beginPath(); ctx.ellipse(0, -sz*0.6, sz*0.3, sz*0.5, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
    ctx.fillStyle = '#ffee44'; ctx.beginPath(); ctx.arc(0, 0, sz*0.35, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // â”€â”€ Luzi â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  drawLuzi(luzi) {
    const ctx = this.ctx;
    const fl  = luzi.invincible>0 && Math.floor(luzi.invincible/6)%2===0;
    if (fl) return;
    const ko = luzi.knockedOut > 0;
    ctx.save();
    ctx.translate(luzi.x+luzi.w/2, luzi.y+luzi.h/2);
    if (luzi.facing < 0) ctx.scale(-1, 1);

    // Schatten
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath(); ctx.ellipse(0, luzi.h/2+2, luzi.w*0.4, 6, 0, 0, Math.PI*2); ctx.fill();

    // Beine
    const ls = Math.sin(luzi.frame*Math.PI/2) * (ko?0:5);
    ctx.fillStyle = '#c8a0e0';
    ctx.beginPath(); ctx.roundRect(-18, 10+ls,  12, 16, 4); ctx.fill();
    ctx.beginPath(); ctx.roundRect(  6, 10-ls,  12, 16, 4); ctx.fill();

    // KÃ¶rper
    const bg = ctx.createRadialGradient(-4, -4, 4, 0, 0, 24);
    bg.addColorStop(0, '#e8c0f8'); bg.addColorStop(1, '#b080d0');
    ctx.fillStyle = bg; ctx.beginPath(); ctx.ellipse(0, 2, 22, 20, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.beginPath(); ctx.ellipse(-2, 4, 10, 8, 0, 0, Math.PI*2); ctx.fill();

    // Kopf
    const hg = ctx.createRadialGradient(-2, -18, 3, 0, -20, 16);
    hg.addColorStop(0, '#eecaff'); hg.addColorStop(1, '#bb88dd');
    ctx.fillStyle = hg; ctx.beginPath(); ctx.ellipse(0, -20, 17, 15, 0, 0, Math.PI*2); ctx.fill();

    // Ohren
    ctx.fillStyle = '#cc99ee'; ctx.beginPath(); ctx.ellipse(-15, -24,  8, 10, Math.PI*0.3, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#ffbbdd'; ctx.beginPath(); ctx.ellipse(-14, -23,  4,  6, Math.PI*0.3, 0, Math.PI*2); ctx.fill();

    // Auge
    if (ko) {
      ctx.strokeStyle = '#442255'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(5,-24); ctx.lineTo(9,-20); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(9,-24); ctx.lineTo(5,-20); ctx.stroke();
    } else {
      ctx.fillStyle = '#442255'; ctx.beginPath(); ctx.arc(7, -22, 3.5, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = 'white';   ctx.beginPath(); ctx.arc(8, -23, 1.2, 0, Math.PI*2); ctx.fill();
    }

    // RÃ¼ssel
    ctx.strokeStyle = '#cc99ee'; ctx.lineWidth = 6; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(14,-18); ctx.quadraticCurveTo(24,-18, 22,-10); ctx.stroke();
    ctx.fillStyle = '#cc99ee'; ctx.beginPath(); ctx.arc(22, -10, 4, 0, Math.PI*2); ctx.fill();

    // Blumenkrone
    this._tinyFlower(0, -36, '#ffaadd', 6);
    ctx.restore();
  }

  // â”€â”€ Gegner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  drawEnemies(enemies) {
    const ctx = this.ctx;
    enemies.forEach(e => {
      if (!e.alive) return;
      if (e.invincible>0 && Math.floor(e.invincible/5)%2===0) return;
      ctx.save();
      ctx.translate(e.x+e.w/2, e.y+e.h/2);

      if (e.type === 'mushroom') {
        ctx.fillStyle='#888899'; ctx.beginPath(); ctx.ellipse(0,8,12,10,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#556677'; ctx.beginPath(); ctx.arc(0,-2,16,Math.PI,0); ctx.fill();
        ctx.fillStyle='#aabbcc';
        ctx.beginPath(); ctx.arc(-4,-6,3,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc( 6,-8,2,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#222';
        ctx.beginPath(); ctx.arc(-4,4,2,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc( 4,4,2,0,Math.PI*2); ctx.fill();

      } else if (e.type === 'crow') {
        ctx.fillStyle='#334455'; ctx.beginPath(); ctx.ellipse(0,0,14,10,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#223344';
        ctx.beginPath(); ctx.ellipse(-12,-4,10,6, Math.PI*0.3,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse( 12,-4,10,6,-Math.PI*0.3,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#334455'; ctx.beginPath(); ctx.arc(0,-10,8,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#889955'; ctx.beginPath(); ctx.moveTo(8,-10); ctx.lineTo(14,-9); ctx.lineTo(8,-7); ctx.fill();
        ctx.fillStyle='#ff4444'; ctx.beginPath(); ctx.arc(-1,-11,2.5,0,Math.PI*2); ctx.fill();

      } else {
        // Schattengeist oder Boss
        const boss = e.type === 'boss';
        if (boss) ctx.scale(1.4, 1.4);
        ctx.fillStyle = boss?'#aa00ff':'#334'; ctx.globalAlpha = 0.88;
        ctx.beginPath(); ctx.ellipse(0,0,14,18,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = boss?'#8800cc':'#223';
        ctx.beginPath(); ctx.moveTo(-14,12); ctx.quadraticCurveTo(-8,22,-4,14);
        ctx.quadraticCurveTo(0,24,4,14); ctx.quadraticCurveTo(8,22,14,12); ctx.fill();
        ctx.globalAlpha = 1;
        ctx.fillStyle = boss?'#ffee00':'#8888ff';
        ctx.beginPath(); ctx.arc(-5,-4,3,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc( 5,-4,3,0,Math.PI*2); ctx.fill();
        // Boss-HP-Anzeige
        if (boss) { for (let hi=0; hi<e.hp; hi++) { ctx.fillStyle='#ffee00'; ctx.fillRect(-10+hi*8,-28,6,4); } }
      }
      ctx.restore();
    });
  }

  // â”€â”€ Blumen-Projektile â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  drawFlowers(flowers) {
    flowers.forEach(f => {
      this.ctx.save(); this.ctx.translate(f.x, f.y); this.ctx.rotate(f.spin);
      this._tinyFlower(0, 0, '#ff66bb', 9);
      this.ctx.restore();
    });
  }

  // â”€â”€ HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  drawHUD(bloomProgress, currentLevel, luzi) {
    const ctx = this.ctx;

    // BlÃ¼ten-Balken
    ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.roundRect(20,16,200,18,9); ctx.fill();
    const bg = ctx.createLinearGradient(20,0,220,0);
    bg.addColorStop(0,'#ff66cc'); bg.addColorStop(1,'#ffcc00');
    ctx.fillStyle = bg; ctx.beginPath(); ctx.roundRect(22,18,196*(bloomProgress/100),14,7); ctx.fill();
    ctx.fillStyle = 'white'; ctx.font = 'bold 11px Georgia'; ctx.fillText('ğŸŒ¸ BlÃ¼ten-Zauber', 25, 30);

    // Level-Name
    ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.roundRect(this.W/2-90,12,180,24,8); ctx.fill();
    ctx.fillStyle = '#ffeeaa'; ctx.font = 'bold 13px Georgia';
    ctx.textAlign = 'center'; ctx.fillText(LEVEL_DATA[currentLevel].name, this.W/2, 29); ctx.textAlign = 'left';

    // Leben
    for (let i = 0; i < 3; i++) {
      ctx.globalAlpha = i < luzi.lives ? 1 : 0.2;
      ctx.font = '22px serif'; ctx.fillText('ğŸŒ¸', this.W-100+i*28, 36);
    }
    ctx.globalAlpha = 1;

    // Steuerung
    ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.font = '10px Georgia';
    ctx.fillText('â† â†’ Bewegen  â†‘ Springen  â†“ Blume schieÃŸen', 20, this.H-8);
  }

  // â”€â”€ MenÃ¼ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  drawMenu(luzi) {
    const ctx = this.ctx;
    const gr = ctx.createLinearGradient(0,0,0,this.H);
    gr.addColorStop(0,'#1a0a2e'); gr.addColorStop(1,'#0d1a0d');
    ctx.fillStyle = gr; ctx.fillRect(0,0,this.W,this.H);

    // Schimmernde Partikel-Dekoration
    for (let i = 0; i < 25; i++) {
      ctx.fillStyle = `hsl(${(i*47+Date.now()*0.02)%360},80%,70%)`;
      ctx.globalAlpha = 0.5+Math.sin(Date.now()*0.003+i)*0.4;
      ctx.beginPath(); ctx.arc(50+(i*73)%700, 30+(i*47)%380, 1.5, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;

    ctx.save();
    ctx.shadowColor = '#ff88cc'; ctx.shadowBlur = 30;
    ctx.fillStyle = '#fff'; ctx.font = 'bold 42px Georgia'; ctx.textAlign = 'center';
    ctx.fillText('Luzi und der', this.W/2, 130);
    ctx.fillStyle = '#ffccee'; ctx.font = 'bold 48px Georgia';
    ctx.fillText('verwunschene Wald', this.W/2, 185);
    ctx.restore();

    // Luzi auf dem MenÃ¼-Bildschirm zentrieren
    luzi.x = this.W/2-26; luzi.y = 220; luzi.facing = 1; luzi.knockedOut = 0; luzi.invincible = 0;
    this.drawLuzi(luzi);

    ctx.fillStyle = 'rgba(255,220,255,0.85)'; ctx.font = '14px Georgia'; ctx.textAlign = 'center';
    ctx.fillText('Der Wald ist verwunschen! Nur Luzi kann ihn', this.W/2, 310);
    ctx.fillText('mit ihren Zauberblumen retten! ğŸŒ¸', this.W/2, 330);
    ctx.fillStyle = `rgba(255,255,100,${0.5+Math.sin(Date.now()*0.004)*0.5})`;
    ctx.font = 'bold 18px Georgia';
    ctx.fillText('[ ENTER ] â€” Abenteuer beginnen!', this.W/2, 390);
    ctx.textAlign = 'left';
  }

  // â”€â”€ Overlay (Level Complete / Game Over) â”€â”€â”€â”€â”€â”€â”€â”€
  drawOverlay(title, sub, hint, col='#ffeecc') {
    const ctx = this.ctx;
    ctx.fillStyle = 'rgba(0,0,0,0.65)'; ctx.fillRect(0,0,this.W,this.H);
    ctx.save(); ctx.shadowColor = col; ctx.shadowBlur = 40; ctx.fillStyle = col;
    ctx.font = 'bold 52px Georgia'; ctx.textAlign = 'center';
    ctx.fillText(title, this.W/2, this.H/2-30); ctx.restore();
    ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.font = '20px Georgia'; ctx.textAlign = 'center';
    ctx.fillText(sub, this.W/2, this.H/2+20);
    ctx.fillStyle = `rgba(255,255,100,${0.5+Math.sin(Date.now()*0.004)*0.5})`;
    ctx.font = '16px Georgia'; ctx.fillText(hint, this.W/2, this.H/2+60); ctx.textAlign = 'left';
  }

  // â”€â”€ Sieg-Screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  drawWinBackground() {
    const ctx = this.ctx;
    const t   = Date.now()*0.001;
    for (let i = 0; i < this.H; i += 4) {
      ctx.fillStyle = `hsl(${(i+t*30)%360},70%,30%)`;
      ctx.fillRect(0, i, this.W, 4);
    }
  }

  drawWinText() {
    const ctx = this.ctx;
    ctx.save(); ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 50; ctx.fillStyle = '#fffacc';
    ctx.font = 'bold 44px Georgia'; ctx.textAlign = 'center';
    ctx.fillText('ğŸŒº Der Wald erblÃ¼ht! ğŸŒº', this.W/2, 160); ctx.restore();
    ctx.fillStyle = 'rgba(255,240,255,0.95)'; ctx.font = '18px Georgia'; ctx.textAlign = 'center';
    ctx.fillText('Luzi hat alle WÃ¤chter besiegt!', this.W/2, 215);
    ctx.fillText('Der verwunschene Wald ist fÃ¼r immer gerettet.', this.W/2, 245);
    ctx.fillText('ğŸ˜ Luzi tanzt vor Freude! ğŸŒ¸', this.W/2, 280);
    ctx.fillStyle = `rgba(255,255,100,${0.5+Math.sin(Date.now()*0.004)*0.5})`;
    ctx.font = 'bold 16px Georgia'; ctx.fillText('[ ENTER ] â€” Von vorne spielen', this.W/2, 370); ctx.textAlign = 'left';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ®  GAME  (Haupt-Controller)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Game {
  constructor() {
    const canvas  = document.getElementById('gameCanvas');
    canvas.width  = CONFIG.CANVAS.W;
    canvas.height = CONFIG.CANVAS.H;

    this.state         = STATE.MENU;
    this.currentLevel  = 0;
    this.bloomProgress = 0;

    this.luzi = {
      x:80, y:340, w:52, h:46,
      vx:0, vy:0, onGround:false,
      lives:3, facing:1,
      invincible:0, knockedOut:0,
      shootCooldown:0, frame:0, frameTimer:0,
    };
    this.flowers   = [];
    this.enemies   = [];
    this.platforms = [];

    this.audio     = new AudioEngine();
    this.input     = new InputManager();
    this.particles = new ParticleSystem();
    this.renderer  = new Renderer(canvas);

    this._lastTime = 0;

    this.input.onKeyDown(e => this._handleKey(e));
  }

  // â”€â”€ Tastatur-Eingabe â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handleKey(e) {
    // Erster Tastendruck startet AudioContext (Browser-Policy)
    this.audio._getContext();
    this.audio.startMusic();

    if (this.state===STATE.MENU && e.key==='Enter') {
      this._startGame();
    } else if (this.state===STATE.LEVEL_COMPLETE && e.key==='Enter') {
      this.currentLevel++;
      if (this.currentLevel >= LEVEL_DATA.length) {
        this.state = STATE.WIN;
        this.audio.playLevelComplete();
      } else {
        this._loadLevel(this.currentLevel);
      }
    } else if (this.state===STATE.GAME_OVER && e.key==='Enter') {
      this._loadLevel(this.currentLevel);
    } else if (this.state===STATE.WIN && e.key==='Enter') {
      this.currentLevel = 0;
      this.state = STATE.MENU;
    }
  }

  // â”€â”€ Level-Verwaltung â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _startGame() {
    this.currentLevel = 0;
    this.audio.startMusic();
    this._loadLevel(0);
  }

  _loadLevel(idx) {
    this.bloomProgress = 0;
    this.flowers = [];
    this.particles.clear();
    const l = this.luzi;
    l.x=80; l.y=340; l.vx=0; l.vy=0; l.lives=3; l.invincible=0; l.knockedOut=0; l.facing=1;
    this.platforms = LEVEL_DATA[idx].platforms.map(p => ({...p}));
    this.enemies   = LEVEL_DATA[idx].enemies.map(e => ({
      ...e, alive:true, hp:e.hp||1, invincible:0, w:38, h:38,
      floatTimer: Math.random()*Math.PI*2,
    }));
    this.state = STATE.PLAYING;
  }

  // â”€â”€ Schaden & Schuss â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _hitLuzi() {
    const l = this.luzi;
    if (l.invincible > 0) return;
    this.audio.playOuch();
    l.lives--;
    l.invincible = CONFIG.PLAYER.INVINCIBLE_FRAMES;
    l.knockedOut = CONFIG.PLAYER.KNOCKOUT_FRAMES;
    l.vy         = CONFIG.PLAYER.KNOCKBACK_VY;
    this.particles.spawn(l.x+l.w/2, l.y+l.h/2, 14, '#ff6688', 4);
    if (l.lives <= 0) this.state = STATE.GAME_OVER;
  }

  _shootFlower() {
    const l = this.luzi;
    this.audio.playTrompete();
    setTimeout(() => this.audio.playWhoosh(), 320);
    const tipX = l.x + (l.facing>0 ? l.w+4 : -8);
    const tipY = l.y + 8;
    this.flowers.push({ x:tipX, y:tipY, w:16, h:16, vx:l.facing*9, vy:0, alive:true, spin:0 });
    this.particles.spawn(tipX, tipY, 6, '#ff88cc', 3);
  }

  // â”€â”€ Update-Logik â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _updateLuzi(dt) {
    const l = this.luzi;
    const { GRAVITY, JUMP, SPEED } = CONFIG.PHYSICS;
    const { W, H } = CONFIG.CANVAS;

    if (l.knockedOut > 0) {
      l.knockedOut -= dt;
      l.vy += GRAVITY; l.y += l.vy;
      resolveGround(l, this.platforms);
      if (l.invincible > 0) l.invincible -= dt;
      return;
    }

    let moving = false;
    if (this.input.isDown('ArrowLeft'))       { l.vx=-SPEED; l.facing=-1; moving=true; }
    else if (this.input.isDown('ArrowRight')) { l.vx= SPEED; l.facing= 1; moving=true; }
    else l.vx *= 0.7;

    if (this.input.isDown('ArrowUp') && l.onGround) {
      l.vy = JUMP; l.onGround = false;
      this.particles.spawn(l.x+l.w/2, l.y+l.h, 4, '#aaffaa', 2);
    }
    if (this.input.isDown('ArrowDown') && l.shootCooldown <= 0) {
      this._shootFlower(); l.shootCooldown = CONFIG.PLAYER.SHOOT_COOLDOWN;
    }
    if (l.shootCooldown > 0) l.shootCooldown -= dt;

    l.vy += GRAVITY; l.x += l.vx; l.y += l.vy;
    l.x = Math.max(0, Math.min(W-l.w, l.x));
    if (l.y > H+60) { this._hitLuzi(); l.x=80; l.y=300; l.vy=0; }

    resolveGround(l, this.platforms);

    // KopfstoÃŸ-Erkennung
    this.platforms.forEach(p => {
      if (l.x+l.w>p.x && l.x<p.x+p.w && l.vy<0 && l.y<=p.y+p.h && l.y>=p.y+p.h-12) {
        l.y=p.y+p.h; l.vy=0;
      }
    });

    if (moving || !l.onGround) {
      l.frameTimer++; if (l.frameTimer>8) { l.frameTimer=0; l.frame=(l.frame+1)%4; }
    } else { l.frame=0; }

    if (l.invincible > 0) l.invincible -= dt;
  }

  _updateEnemies(dt) {
    const W = CONFIG.CANVAS.W;
    this.enemies.forEach(e => {
      if (!e.alive) return;
      if (e.invincible > 0) e.invincible -= dt;

      if (e.type==='mushroom' || e.type==='shadow') {
        e.x += e.dir*e.speed;
        if (e.x<10 || e.x>W-50) e.dir *= -1;
      } else if (e.type==='crow') {
        e.floatTimer += 0.05;
        e.x += e.dir*e.speed;
        e.y  = e.floatY + Math.sin(e.floatTimer)*e.floatRange;
        if (e.x<10 || e.x>W-50) e.dir *= -1;
      } else if (e.type==='boss') {
        e.x += e.dir*e.speed;
        if (e.x<580 || e.x>W-70) e.dir *= -1;
        if (Math.abs(this.luzi.x-e.x) < 200) e.x += (this.luzi.x>e.x ? 0.5 : -0.5);
      }

      if (overlap(e, this.luzi)) this._hitLuzi();
    });
  }

  _updateFlowers(dt) {
    const { W, H } = CONFIG.CANVAS;
    this.flowers.forEach(f => {
      if (!f.alive) return;
      f.x+=f.vx; f.y+=f.vy; f.spin+=0.22;
      if (f.x<-40||f.x>W+40||f.y<-40||f.y>H+40) { f.alive=false; return; }

      this.enemies.forEach(e => {
        if (!e.alive || e.invincible>0) return;
        // GroÃŸzÃ¼gige Hitbox â€” Bodengegner gut treffbar
        const eHit = { x:e.x-4, y:e.y-4, w:e.w+8, h:e.h+8 };
        const fHit = { x:f.x-6, y:f.y-6, w:f.w+12, h:f.h+12 };
        if (overlap(eHit, fHit)) {
          f.alive = false;
          this.audio.playHit();
          this.particles.spawn(e.x+e.w/2, e.y+e.h/2, 15, '#ff88cc', 4);
          this.particles.spawn(e.x+e.w/2, e.y+e.h/2,  9, '#ffcc00', 3);
          e.hp--;
          if (e.hp <= 0) {
            e.alive = false;
            // Verteile 100% gleichmÃ¤ÃŸig auf alle Gegner des Levels
            this.bloomProgress += Math.ceil(100 / LEVEL_DATA[this.currentLevel].enemies.length);
            if (this.bloomProgress > 100) this.bloomProgress = 100;
          } else {
            e.invincible = 55;
          }
        }
      });
    });
    this.flowers = this.flowers.filter(f => f.alive);

    if (this.bloomProgress>=100 && this.state===STATE.PLAYING) {
      this.audio.playLevelComplete();
      for (let i=0; i<32; i++) {
        this.particles.spawn(
          Math.random()*W, Math.random()*H,
          3, ['#ff88cc','#ffcc00','#aaffaa','#88ccff'][i%4], 5
        );
      }
      this.state = STATE.LEVEL_COMPLETE;
    }
  }

  // â”€â”€ Haupt-Game-Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  run() {
    const loop = ts => {
      const dt  = Math.min((ts-this._lastTime)/16.67, 3);
      this._lastTime = ts;

      const r   = this.renderer;
      const lvl = LEVEL_DATA[this.currentLevel];
      r.clear();

      if (this.state === STATE.MENU) {
        r.drawMenu(this.luzi);

      } else if (this.state===STATE.PLAYING || this.state===STATE.LEVEL_COMPLETE) {
        if (this.state === STATE.PLAYING) {
          this._updateLuzi(dt); this._updateEnemies(dt); this._updateFlowers(dt);
        }
        this.particles.update();
        r.drawBackground(lvl, this.bloomProgress);
        r.drawPlatforms(this.platforms, lvl, this.bloomProgress);
        r.drawEnemies(this.enemies);
        r.drawFlowers(this.flowers);
        r.drawLuzi(this.luzi);
        this.particles.draw(r.ctx);
        r.drawHUD(this.bloomProgress, this.currentLevel, this.luzi);
        if (this.state === STATE.LEVEL_COMPLETE) {
          r.drawOverlay(
            'ğŸŒ¸ ErblÃ¼ht! ğŸŒ¸',
            this.currentLevel < LEVEL_DATA.length-1
              ? `Weiter: "${LEVEL_DATA[this.currentLevel+1]?.name}"`
              : 'Der Wald erwacht!',
            '[ ENTER ] â€” Weiter', '#ffccee'
          );
        }

      } else if (this.state === STATE.GAME_OVER) {
        r.drawBackground(lvl, this.bloomProgress);
        r.drawPlatforms(this.platforms, lvl, this.bloomProgress);
        r.drawLuzi(this.luzi);
        r.drawHUD(this.bloomProgress, this.currentLevel, this.luzi);
        r.drawOverlay('ğŸ˜¢ OhnmÃ¤chtig!', 'Luzi braucht eine Pause...', '[ ENTER ] â€” Nochmal versuchen', '#ffaaaa');

      } else if (this.state === STATE.WIN) {
        r.drawWinBackground();
        if (Math.random() < 0.3) {
          this.particles.spawn(
            Math.random()*CONFIG.CANVAS.W, Math.random()*CONFIG.CANVAS.H/2,
            5, ['#ff88cc','#ffcc00','#aaffaa','#88ccff'][Math.floor(Math.random()*4)], 4
          );
        }
        this.particles.update();
        this.particles.draw(r.ctx);
        r.drawWinText();
      }

      requestAnimationFrame(loop);
    };
    requestAnimationFrame(loop);
  }
}

// â”€â”€â”€ STARTEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const game = new Game();
game.run();
</script>
</body>
</html>
